# 机械臂控制系统 - 完整功能框图及程序流程图

## 系统架构流程图

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                              系统整体架构流程图                                           │
└─────────────────────────────────────────────────────────────────────────────────────────┘


    ┌───────────────────────────────────────────────────────────────────────────────┐
    │                           OH开发板 (OpenHarmony)                               │
    │  ┌─────────────────────────────────────────────────────────────────────────┐  │
    │  │                                                                         │  │
    │  │   ┌─────────────────────────┐         ┌─────────────────────────┐      │  │
    │  │   │                         │         │                         │      │  │
    │  │   │      鸿蒙应用 (前端)     │         │     Flask后端服务       │      │  │
    │  │   │                         │         │                         │      │  │
    │  │   │   ┌─────────────────┐   │         │   ┌─────────────────┐   │      │  │
    │  │   │   │  用户界面 UI    │   │         │   │  netService.py  │   │      │  │
    │  │   │   │  • 关节控制     │   │         │   │  • 路由处理     │   │      │  │
    │  │   │   │  • 传送带控制   │   │  HTTP   │   │  • 指令编码     │   │      │  │
    │  │   │   │  • 搬运控制     │   │ ──────► │   │  • 状态管理     │   │      │  │
    │  │   │   │  • 动作录制     │   │  POST   │   │  • 线程控制     │   │      │  │
    │  │   │   │  • 状态显示     │   │  :5000  │   │                 │   │      │  │
    │  │   │   └─────────────────┘   │         │   └────────┬────────┘   │      │  │
    │  │   │                         │         │            │            │      │  │
    │  │   │   ┌─────────────────┐   │         │            │            │      │  │
    │  │   │   │  index.js       │   │  JSON   │            │            │      │  │
    │  │   │   │  index.html     │   │ ◄────── │            │            │      │  │
    │  │   │   │  index.css      │   │  响应   │            │            │      │  │
    │  │   │   └─────────────────┘   │         │            │            │      │  │
    │  │   │                         │         │            │            │      │  │
    │  │   └─────────────────────────┘         └────────────┼────────────┘      │  │
    │  │                                                    │                   │  │
    │  └────────────────────────────────────────────────────┼───────────────────┘  │
    │                                                       │                      │
    └───────────────────────────────────────────────────────┼──────────────────────┘
                                                            │
                                                            │  Modbus TCP
                                                            │  192.168.1.103:502
                                                            │
                                                            │  ┌─────────────────┐
                                                            │  │ 写寄存器指令    │
                                                            │  │ (功能码: 06)    │
                                                            ▼  └─────────────────┘
    ┌───────────────────────────────────────────────────────────────────────────────┐
    │                               电脑 (PC)                                        │
    │  ┌─────────────────────────────────────────────────────────────────────────┐  │
    │  │                                                                         │  │
    │  │                          虚拟工厂仿真软件                                │  │
    │  │                                                                         │  │
    │  │   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │  │
    │  │   │             │  │             │  │             │  │             │   │  │
    │  │   │  6轴机械臂  │  │  传送带 x2  │  │  颜色传感器 │  │  LED数码管  │   │  │
    │  │   │             │  │             │  │             │  │             │   │  │
    │  │   │  Slave: 1   │  │  Addr: 7,8  │  │  Addr: 14   │  │  Slave: 4   │   │  │
    │  │   │  Addr: 0-6  │  │             │  │             │  │  Addr: 0-2  │   │  │
    │  │   │             │  │             │  │             │  │             │   │  │
    │  │   └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │  │
    │  │                                                                         │  │
    │  │                        ▲  接收指令并执行仿真动作                         │  │
    │  │                                                                         │  │
    │  └─────────────────────────────────────────────────────────────────────────┘  │
    │                                                                               │
    └───────────────────────────────────────────────────────────────────────────────┘


                              ┌─────────────────────────┐
                              │       通信流程说明       │
                              └─────────────────────────┘

    ┌──────────┐          ┌──────────┐          ┌──────────────────┐
    │          │   HTTP   │          │  Modbus  │                  │
    │  前端    │ ───────► │  后端     │ ───────► │    虚拟工厂       │
    │  (鸿蒙)  │   POST   │ (Flask)  |   TCP     │    (PC仿真)      │
    │          │          │          │          │                  │
    └──────────┘          └──────────┘          └──────────────────┘
         │                     │                       │
         │  1.用户点击按钮      │  2.解析请求            │  3.执行动作
         │  发送HTTP请求        │  编码为Modbus指令      │  机械臂运动
         │                     │  通过TCP发送           │  传送带转动
         ▼                     ▼                       ▼
    ┌──────────┐          ┌──────────┐          ┌──────────────────┐
    │ 用户操作 │           │ 指令处理 │           │   仿真执行       │
    │ • 选关节 │           │ • 路由   │           │   • 机械臂控制   │
    │ • 选方向 │           │ • 编码   │           │   • 传送带控制   │
    │ • 选角度 │           │ • 发送   │           │   • 颜色识别     │
    │ • 确认   │           │ • 响应   │           │   • LED显示      │
    └──────────┘          └──────────┘           └──────────────────┘
```

## 〇、程序总体流程图

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                   程序总体流程图                                          │
└─────────────────────────────────────────────────────────────────────────────────────────┘

                                    ┌───────────────┐
                                    │   系统启动     │
                                    └───────┬───────┘
                                            │
                    ┌───────────────────────┼───────────────────────┐
                    │                       │                       │
                    ▼                       ▼                       ▼
        ┌───────────────────┐   ┌───────────────────┐   ┌───────────────────┐
        │   初始化日志系统   │   │  初始化Flask应用  │   │ 建立Modbus TCP连接│
        │ pythonapp.log     │   │   端口: 5000      │   │ 192.168.1.103:502 │
        └───────────────────┘   └───────────────────┘   └───────────────────┘
                    │                       │                       │
                    └───────────────────────┼───────────────────────┘
                                            │
                                            ▼
                              ┌─────────────────────────┐
                              │   启动Web服务器监听     │
                              │   host: 0.0.0.0:5000   │
                              └───────────┬─────────────┘
                                          │
                                          ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                     主事件循环                                           │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐   │
│  │                              等待HTTP请求                                        │   │
│  └─────────────────────────────────────┬───────────────────────────────────────────┘   │
│                                        │                                               │
│                                        ▼                                               │
│                         ┌──────────────────────────────┐                               │
│                         │        接收并解析请求         │                               │
│                         └──────────────┬───────────────┘                               │
│                                        │                                               │
│    ┌───────────┬───────────┬──────────┼──────────┬───────────┬───────────┐            │
│    │           │           │          │          │           │           │            │
│    ▼           ▼           ▼          ▼          ▼           ▼           ▼            │
│ ┌──────┐  ┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐           │
│ │/send │  │/reset│   │/pump │   │/start│   │/start│   │/pause│   │/Soft │           │
│ │      │  │      │   │/pump2│   │_trans│   │_record   │_trans│   │Reset │           │
│ │手动  │  │复位  │   │      │   │port  │   │/end_ │   │port  │   │      │           │
│ │控制  │  │      │   │传送带│   │      │   │record│   │      │   │软复位│           │
│ └──┬───┘  └──┬───┘   └──┬───┘   └──┬───┘   └──┬───┘   └──┬───┘   └──┬───┘           │
│    │         │          │          │          │          │          │               │
│    ▼         ▼          ▼          ▼          ▼          ▼          ▼               │
│ ┌─────────────────────────────────────────────────────────────────────────────┐     │
│ │                           业务逻辑处理层                                     │     │
│ ├─────────────────────────────────────────────────────────────────────────────┤     │
│ │                                                                             │     │
│ │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │     │
│ │  │ 参数解析    │  │ 指令编码    │  │ 状态管理    │  │ 线程控制    │        │     │
│ │  │ JSON数据    │  │ 命令映射    │  │ 录制/暂停   │  │ 后台搬运    │        │     │
│ │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘        │     │
│ │                                                                             │     │
│ └───────────────────────────────────┬─────────────────────────────────────────┘     │
│                                     │                                               │
│                                     ▼                                               │
│ ┌─────────────────────────────────────────────────────────────────────────────┐     │
│ │                         Modbus TCP 通信层                                    │     │
│ ├─────────────────────────────────────────────────────────────────────────────┤     │
│ │                                                                             │     │
│ │  ┌───────────────────┐        ┌───────────────────┐                        │     │
│ │  │ WRITE_SINGLE_     │        │ READ_HOLDING_     │                        │     │
│ │  │ REGISTER (06)     │        │ REGISTERS (03)    │                        │     │
│ │  │ 写入控制指令       │        │ 读取传感器数据    │                        │     │
│ │  └─────────┬─────────┘        └─────────┬─────────┘                        │     │
│ │            │                            │                                   │     │
│ │            └────────────┬───────────────┘                                   │     │
│ │                         │                                                   │     │
│ └─────────────────────────┼───────────────────────────────────────────────────┘     │
│                           │                                                         │
│                           ▼                                                         │
│ ┌─────────────────────────────────────────────────────────────────────────────┐     │
│ │                              硬件设备层                                      │     │
│ ├─────────────────────────────────────────────────────────────────────────────┤     │
│ │                                                                             │     │
│ │   ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐         │     │
│ │   │ 6轴     │  │ 1号     │  │ 2号     │  │ 颜色    │  │ LED     │         │     │
│ │   │ 机械臂  │  │ 传送带  │  │ 传送带  │  │ 传感器  │  │ 数码管  │         │     │
│ │   │Slave:1  │  │Addr:7   │  │Addr:8   │  │Addr:14  │  │Slave:4  │         │     │
│ │   │Addr:0-6 │  │         │  │         │  │         │  │Addr:0-2 │         │     │
│ │   └─────────┘  └─────────┘  └─────────┘  └─────────┘  └─────────┘         │     │
│ │                                                                             │     │
│ └─────────────────────────────────────────────────────────────────────────────┘     │
│                                     │                                               │
│                                     ▼                                               │
│                         ┌───────────────────────┐                                   │
│                         │    返回JSON响应       │                                   │
│                         │ {status, response}   │                                   │
│                         └───────────┬───────────┘                                   │
│                                     │                                               │
│                                     └─────────────────► 返回主循环继续等待请求        │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘

## 通信驱动程序代码及解释

### 一、通信架构概述

本系统采用**两层通信架构**：
1. **前端 ↔ 后端**：HTTP REST API (基于Flask框架)
2. **后端 ↔ 虚拟工厂**：Modbus TCP工业协议

```
┌─────────────┐      HTTP/JSON       ┌─────────────┐     Modbus TCP      ┌─────────────┐
│  鸿蒙前端   │ ──────────────────► │  Flask后端  │ ──────────────────► │  虚拟工厂   │
│  index.js   │ ◄────────────────── │netService.py│ ◄────────────────── │  (PC仿真)   │
└─────────────┘      JSON响应        └─────────────┘     寄存器读写       └─────────────┘
```

---

### 二、后端Modbus TCP通信驱动代码

#### 2.1 导入模块与初始化连接

```python
# 文件: netService.py

from flask import Flask, request, jsonify
import modbus_tk.modbus_tcp as modbus_tcp   # Modbus TCP通信库
import modbus_tk.defines as cst              # Modbus功能码定义
import logging
import time
import threading



# ============================================
# 关键代码：建立Modbus TCP主站连接
# ============================================
# host: 虚拟工厂所在电脑的IP地址
# port: Modbus TCP标准端口502
master_tcp = modbus_tcp.TcpMaster(host="192.168.1.103", port=502)
```

**代码解释：**
- `modbus_tk` 是Python的Modbus通信库，支持TCP和RTU两种模式
- `TcpMaster` 创建一个Modbus TCP主站（Master），作为通信发起方
- `host="192.168.1.103"` 是运行虚拟工厂软件的电脑IP地址
- `port=502` 是Modbus TCP协议的标准端口

---

#### 2.2 命令编码映射表

```python
# ============================================
# 关键代码：机械臂控制指令编码表
# ============================================
command = {
    "forward1": 1,   # 正向旋转1°，编码为1
    "forward2": 2,   # 正向旋转2°，编码为2
    "forward3": 3,   # 正向旋转3°，编码为3
    "forward5": 4,   # 正向旋转5°，编码为4
    "backward1": 5,  # 反向旋转1°，编码为5
    "backward2": 6,  # 反向旋转2°，编码为6
    "backward3": 7,  # 反向旋转3°，编码为7
    "backward5": 8   # 反向旋转5°，编码为8
}
```

**代码解释：**
- 该字典将人类可读的指令（如"forward1"）映射为Modbus寄存器值（1-8）
- 虚拟工厂根据这些编码值执行相应的机械臂动作

---

#### 2.3 核心通信函数：写单个寄存器

```python
# ============================================
# 关键代码：手动控制机械臂关节
# ============================================
@app.route("/send", methods=["POST"])
def send():
    # 1. 解析前端发来的JSON数据
    data = request.json
    jointIndex = data.get("jointIndex")   # 关节索引 (0-6)
    direction = data.get("direction")      # 方向 (forward/backward)
    degree = data.get("degree")            # 角度 (1/2/3/5)

    # 2. 计算复位角度（用于撤销操作）
    reset_degree = (command[f"{direction}{degree}"] + 4) % 8
    if reset_degree == 0:
        reset_degree = 8

    # 3. 记录日志
    logging.info(f'send(): jointIndex: {jointIndex}, direction: {direction}, degree: {degree}')

    # ============================================
    # 核心代码：通过Modbus TCP发送控制指令
    # ============================================
    try:
        res = master_tcp.execute(
            slave=1,                                    # 从站地址：1号机械臂
            function_code=cst.WRITE_SINGLE_REGISTER,   # 功能码06：写单个寄存器
            starting_address=jointIndex,               # 寄存器地址：关节索引
            output_value=command[f"{direction}{degree}"] # 写入值：编码后的指令
        )
        return jsonify({"status": "success", "res": str(res)})
    except Exception as e:
        logging.error(f"Error: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500
```

**代码解释：**
- `master_tcp.execute()` 是核心通信函数，用于向虚拟工厂发送Modbus指令
- **参数说明：**
  | 参数 | 说明 | 示例值 |
  |------|------|--------|
  | `slave` | 从站设备地址 | 1 (机械臂), 4 (LED数码管) |
  | `function_code` | Modbus功能码 | `cst.WRITE_SINGLE_REGISTER` (06) |
  | `starting_address` | 寄存器起始地址 | 0-6 (关节), 7 (传送带1), 8 (传送带2) |
  | `output_value` | 写入的值 | 1-8 (动作编码) |

---

#### 2.4 传送带控制通信

```python
# ============================================
# 关键代码：控制1号传送带
# ============================================
@app.route("/pump", methods=["POST"])
def pump():
    data = request.json
    action = data.get("action")  # True=开启, False=关闭

    try:
        res = master_tcp.execute(
            slave=1,                                  # 从站地址
            function_code=cst.WRITE_SINGLE_REGISTER, # 功能码06
            starting_address=7,                      # 寄存器地址7：1号传送带
            output_value=1 if action else 2          # 1=开启, 2=关闭
        )
    except Exception as e:
        return jsonify({"error": str(e)})
    return jsonify({"response": res})


# ============================================
# 关键代码：控制2号传送带
# ============================================
@app.route("/pump2", methods=["POST"])
def pump2():
    data = request.json
    action = data.get("action")

    try:
        res = master_tcp.execute(
            slave=1,
            function_code=cst.WRITE_SINGLE_REGISTER,
            starting_address=8,                      # 寄存器地址8：2号传送带
            output_value=1 if action else 2
        )
    except Exception as e:
        return jsonify({"error": str(e)})
    return jsonify({"response": res})
```

---

#### 2.5 颜色传感器读取（读寄存器）

```python
# ============================================
# 关键代码：读取颜色传感器数据
# ============================================
# 在自动搬运流程中使用
res = master_tcp.execute(
    slave=1,                                    # 从站地址
    function_code=cst.READ_HOLDING_REGISTERS,   # 功能码03：读保持寄存器
    starting_address=0x000E,                    # 寄存器地址14：颜色传感器
    quantity_of_x=1                             # 读取1个寄存器
)
# res[0] 返回颜色代码：1=红色, 其他=非红色
color_code = res[0] if res else 0
```

**代码解释：**
- `cst.READ_HOLDING_REGISTERS` 是Modbus功能码03，用于读取数据
- 颜色传感器返回值：`1` 表示红色，其他值表示非红色

---

#### 2.6 LED数码管控制

```python
# ============================================
# 关键代码：控制LED数码管显示
# ============================================
@app.route("/change_Led", methods=["POST"])
def change_Led():
    data = request.json
    num = data.get("num", 10)
    
    # 分离十位和个位
    tens = num // 10
    ones = num % 10
    if ones == 0: ones = 10
    if tens == 0: tens = 10

    try:
        # 开启数码管显示
        master_tcp.execute(
            slave=4,                                  # 从站地址4：LED数码管
            function_code=cst.WRITE_SINGLE_REGISTER,
            starting_address=0x0002,                 # 地址2：显示开关
            output_value=1                           # 1=开启显示
        )
        
        # 设置十位数字
        master_tcp.execute(
            slave=4,
            function_code=cst.WRITE_SINGLE_REGISTER,
            starting_address=0x0000,                 # 地址0：十位
            output_value=tens
        )
        
        # 设置个位数字
        master_tcp.execute(
            slave=4,
            function_code=cst.WRITE_SINGLE_REGISTER,
            starting_address=0x0001,                 # 地址1：个位
            output_value=ones
        )
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500
    
    return jsonify({"response": res})
```

---

### 三、前端HTTP通信驱动代码

#### 3.1 HarmonyOS Fetch API调用

```javascript
// 文件: frontend/static/index.js

// 导入鸿蒙系统的fetch模块
import fetch from '@system.fetch'

// ============================================
// 关键代码：发送机械臂控制请求
// ============================================
rotate(direction, degree) {
    fetch.fetch({
        url: 'http://127.0.0.1:5000/send',    // 后端API地址
        method: 'POST',                        // HTTP POST方法
        data: {                                // 请求体数据
            jointIndex: this.jointIndex,       // 关节索引
            direction: direction,              // 方向
            degree: degree                     // 角度
        },
        success: res => console.log('响应:', res.data),
        fail: err => console.error('请求失败:', err)
    });
}
```

**代码解释：**
- `@system.fetch` 是HarmonyOS提供的网络请求模块
- `url: 'http://127.0.0.1:5000/send'` 指向本地Flask后端服务
- `data` 对象会被自动序列化为JSON格式发送

---

#### 3.2 传送带控制请求

```javascript
// ============================================
// 关键代码：控制传送带开关
// ============================================
bump() {
    fetch.fetch({
        url: 'http://127.0.0.1:5000/pump',
        method: 'POST',
        data: {
            action: !this.pump,  // 切换开关状态
        },
        success: res => {
            let payload = res.data;
            // 解析JSON响应
            if (typeof payload === 'string') {
                payload = JSON.parse(payload);
            }
            if (payload.response) {
                this.pump = !this.pump;  // 更新UI状态
            }
        },
        fail: err => console.error('连接失败:', err),
    });
}
```

---

#### 3.3 自动搬运控制与状态轮询

```javascript
// ============================================
// 关键代码：启动自动搬运
// ============================================
startTransport() {
    fetch.fetch({
        url: 'http://127.0.0.1:5000/start_transport',
        method: 'POST',
        data: {
            num: this.transportNum,      // 搬运数量
            count_box: this.count_box,   // 已搬运数量
            red_box: this.red_box        // 红色箱子数量
        },
        success: res => {
            console.log('搬运启动:', res.data);
            this.pollTransportStatus();  // 启动状态轮询
        }
    });
}

// ============================================
// 关键代码：轮询搬运状态
// ============================================
pollTransportStatus() {
    const poll = () => {
        fetch.fetch({
            url: 'http://127.0.0.1:5000/get_transport_status',
            method: 'GET',
            success: res => {
                let data = JSON.parse(res.data);
                // 更新UI显示
                this.count_box = data.result.count_box;
                this.red_box = data.result.red_box;
                
                // 如果还在运行，继续轮询
                if (data.running) {
                    setTimeout(poll, 1000);  // 1秒后再次查询
                }
            }
        });
    };
    setTimeout(poll, 1000);
}
```

---

### 四、Modbus通信协议详解

#### 4.1 Modbus TCP帧结构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Modbus TCP 数据帧结构                             │
├─────────────┬─────────────┬─────────────┬─────────────┬─────────────────┤
│ 事务标识符  │ 协议标识符  │  长度字段   │  单元标识符 │    PDU数据      │
│  (2字节)    │  (2字节)    │  (2字节)    │   (1字节)   │   (N字节)       │
├─────────────┼─────────────┼─────────────┼─────────────┼─────────────────┤
│   0x0001    │   0x0000    │   0x0006    │    0x01     │  功能码+数据    │
└─────────────┴─────────────┴─────────────┴─────────────┴─────────────────┘
```

#### 4.2 本系统使用的功能码

| 功能码 | 名称 | 用途 | 示例 |
|--------|------|------|------|
| 03 | READ_HOLDING_REGISTERS | 读取寄存器 | 读取颜色传感器值 |
| 06 | WRITE_SINGLE_REGISTER | 写单个寄存器 | 控制机械臂/传送带 |

#### 4.3 设备地址映射表

| 从站(Slave) | 设备 | 寄存器地址 | 功能 |
|-------------|------|-----------|------|
| 1 | 机械臂 | 0 | 1号关节控制 |
| 1 | 机械臂 | 1 | 2号关节控制 |
| 1 | 机械臂 | 2 | 3号关节控制 |
| 1 | 机械臂 | 3 | 4号关节控制 |
| 1 | 机械臂 | 4 | 5号关节控制 |
| 1 | 机械臂 | 5 | 6号关节控制 |
| 1 | 机械臂 | 6 | 吸盘控制 |
| 1 | 机械臂 | 7 | 1号传送带 |
| 1 | 机械臂 | 8 | 2号传送带 |
| 1 | 机械臂 | 14 | 颜色传感器(只读) |
| 4 | LED数码管 | 0 | 十位数字 |
| 4 | LED数码管 | 1 | 个位数字 |
| 4 | LED数码管 | 2 | 显示开关 |

---

### 五、通信流程时序图

```
┌─────────┐          ┌─────────┐          ┌─────────────┐
│  前端   │          │  后端   │          │  虚拟工厂   │
│(鸿蒙App)│          │(Flask)  │          │ (Modbus设备)│
└────┬────┘          └────┬────┘          └──────┬──────┘
     │                    │                      │
     │  1. HTTP POST      │                      │
     │  /send             │                      │
     │  {jointIndex:0,    │                      │
     │   direction:"fwd", │                      │
     │   degree:5}        │                      │
     │ ─────────────────► │                      │
     │                    │                      │
     │                    │  2. Modbus TCP       │
     │                    │  功能码: 06          │
     │                    │  Slave: 1            │
     │                    │  Addr: 0             │
     │                    │  Value: 4            │
     │                    │ ────────────────────►│
     │                    │                      │
     │                    │                      │ 3. 执行动作
     │                    │                      │    机械臂1号关节
     │                    │                      │    正向旋转5°
     │                    │                      │
     │                    │  4. Modbus响应       │
     │                    │ ◄────────────────────│
     │                    │                      │
     │  5. JSON响应       │                      │
     │  {"status":"ok"}   │                      │
     │ ◄───────────────── │                      │
     │                    │                      │
     ▼                    ▼                      ▼
```


                            ┌─────────────────────────────┐
                            │       自动搬运子流程         │
                            │    (后台线程 do_transport)   │
                            └──────────────┬──────────────┘
                                           │
                                           ▼
                            ┌─────────────────────────────┐
                            │     初始化搬运参数          │
                            │  num, count_box, red_box    │
                            └──────────────┬──────────────┘
                                           │
                                           ▼
                      ┌────────────────────┴────────────────────┐
                      │            while(num > 0)               │
                      └────────────────────┬────────────────────┘
                                           │
                         ┌─────────────────┴─────────────────┐
                         │          检查暂停状态              │
                         │       transport_paused?           │
                         └─────────────────┬─────────────────┘
                                  是│              │否
                                    ▼              │
                         ┌─────────────────┐       │
                         │  等待暂停解除   │       │
                         │  time.sleep     │       │
                         └────────┬────────┘       │
                                  └────────────────┤
                                                   ▼
                         ┌─────────────────────────────────────┐
                         │         更新LED数码管显示           │
                         │      显示当前搬运进度               │
                         └─────────────────┬───────────────────┘
                                           │
                                           ▼
                         ┌─────────────────────────────────────┐
                         │      执行auto_instructions指令      │
                         │   (预设的搬运动作序列)              │
                         └─────────────────┬───────────────────┘
                                           │
                         ┌─────────────────┴─────────────────┐
                         │        指令类型判断                │
                         └─────────────────┬─────────────────┘
                              普通│                │颜色识别
                              指令│                │(addr=14)
                                  ▼                ▼
                  ┌─────────────────────┐  ┌─────────────────────┐
                  │ 发送Modbus写指令    │  │ 循环读取颜色传感器   │
                  │ 控制机械臂/传送带   │  │ 直到检测到物体       │
                  └─────────┬───────────┘  └─────────┬───────────┘
                            │                        │
                            │                ┌───────┴───────┐
                            │                │  颜色=红色?    │
                            │                └───────┬───────┘
                            │                   是│      │否
                            │                     ▼      │
                            │              ┌──────────┐  │
                            │              │red_box++ │  │
                            │              └────┬─────┘  │
                            │                   └────────┤
                            └────────────────────────────┤
                                                         ▼
                         ┌─────────────────────────────────────┐
                         │           执行吸盘操作              │
                         │      吸取 → 移动 → 放置            │
                         └─────────────────┬───────────────────┘
                                           │
                                           ▼
                         ┌─────────────────────────────────────┐
                         │         机械臂复位                  │
                         │       回到初始位置                  │
                         └─────────────────┬───────────────────┘
                                           │
                                           ▼
                         ┌─────────────────────────────────────┐
                         │   num--; count_box++               │
                         │   更新transport_result             │
                         └─────────────────┬───────────────────┘
                                           │
                                           ▼
                              ┌────────────┴────────────┐
                              │       num > 0 ?         │
                              └────────────┬────────────┘
                                    是│          │否
                                      │          ▼
                                      │    ┌───────────────┐
                                      │    │  搬运完成     │
                                      │    │ 更新最终状态  │
                                      │    └───────────────┘
                                      │
                                      └──────► 继续循环
```

## 一、系统功能框图

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              机械臂控制系统                                       │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  ┌─────────────────────┐         HTTP/REST API        ┌─────────────────────┐  │
│  │                     │◄─────────────────────────────►│                     │  │
│  │   前端控制界面       │                               │   Flask后端服务     │  │
│  │   (HarmonyOS)       │                               │   (Python)          │  │
│  │                     │                               │                     │  │
│  └─────────────────────┘                               └──────────┬──────────┘  │
│           │                                                       │             │
│           │                                                       │             │
│           ▼                                                       ▼             │
│  ┌─────────────────────┐                               ┌─────────────────────┐  │
│  │   用户交互模块       │                               │   Modbus TCP通信    │  │
│  │  ┌───────────────┐  │                               │   (192.168.1.103)   │  │
│  │  │ 关节选择      │  │                               └──────────┬──────────┘  │
│  │  │ 方向选择      │  │                                          │             │
│  │  │ 角度选择      │  │                                          ▼             │
│  │  │ 传送带控制    │  │                               ┌─────────────────────┐  │
│  │  │ 搬运控制      │  │                               │   硬件设备层         │  │
│  │  │ 动作录制/回放 │  │                               │  ┌───────────────┐  │  │
│  │  └───────────────┘  │                               │  │ 6轴机械臂     │  │  │
│  └─────────────────────┘                               │  │ 1号传送带     │  │  │
│                                                        │  │ 2号传送带     │  │  │
│                                                        │  │ 颜色传感器    │  │  │
│                                                        │  │ LED数码管     │  │  │
│                                                        │  │ 吸盘装置      │  │  │
│                                                        │  └───────────────┘  │  │
│                                                        └─────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

## 二、模块功能说明

```
┌───────────────────────────────────────────────────────────────────────────────┐
│                              功能模块结构                                      │
├───────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐           │
│  │  手动控制模块    │    │  自动搬运模块    │    │  动作录制模块    │           │
│  ├─────────────────┤    ├─────────────────┤    ├─────────────────┤           │
│  │ /send           │    │ /start_transport│    │ /start_record   │           │
│  │ • 6关节控制     │    │ • 自动搬运流程  │    │ • 开始录制      │           │
│  │ • 正/反向旋转   │    │ • 颜色识别      │    │ /end_record     │           │
│  │ • 1°/2°/3°/5°  │    │ • 红色计数      │    │ • 结束录制      │           │
│  │                 │    │ • 循环搬运      │    │ /start_action   │           │
│  │ /reset          │    │                 │    │ • 执行录制动作  │           │
│  │ • 复位操作      │    │ /pause_transport│    │                 │           │
│  │                 │    │ • 暂停/继续     │    │                 │           │
│  │ /SoftReset      │    │                 │    │                 │           │
│  │ • 软复位        │    │ /get_transport  │    │                 │           │
│  │                 │    │   _status       │    │                 │           │
│  │                 │    │ • 获取搬运状态  │    │                 │           │
│  └─────────────────┘    └─────────────────┘    └─────────────────┘           │
│                                                                               │
│  ┌─────────────────┐    ┌─────────────────┐                                  │
│  │  传送带控制模块  │    │  显示控制模块    │                                  │
│  ├─────────────────┤    ├─────────────────┤                                  │
│  │ /pump           │    │ /change_Led     │                                  │
│  │ • 1号传送带     │    │ • LED数码管显示 │                                  │
│  │ • 开启/关闭     │    │ • 显示搬运数量  │                                  │
│  │                 │    │                 │                                  │
│  │ /pump2          │    │                 │                                  │
│  │ • 2号传送带     │    │                 │                                  │
│  │ • 开启/关闭     │    │                 │                                  │
│  └─────────────────┘    └─────────────────┘                                  │
│                                                                               │
└───────────────────────────────────────────────────────────────────────────────┘
```

## 三、主程序流程图

```
                    ┌─────────────────┐
                    │     程序启动     │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │  初始化日志配置  │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ 建立Modbus TCP  │
                    │ 连接(192.168.1  │
                    │ .103:502)       │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ 初始化Flask应用  │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ 启动Web服务器   │
                    │ (0.0.0.0:5000)  │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │   等待请求      │◄──────────┐
                    └────────┬────────┘           │
                             │                    │
                             ▼                    │
                    ┌─────────────────┐           │
                    │   接收HTTP请求   │           │
                    └────────┬────────┘           │
                             │                    │
                             ▼                    │
            ┌────────────────┴────────────────┐   │
            │           路由分发               │   │
            └────────────────┬────────────────┘   │
                             │                    │
       ┌──────────┬──────────┼──────────┬────────┤
       ▼          ▼          ▼          ▼        │
   ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐      │
   │ /send │ │/start │ │ /pump │ │ /reset│      │
   │       │ │_trans │ │/pump2 │ │       │      │
   │       │ │ port  │ │       │ │       │      │
   └───┬───┘ └───┬───┘ └───┬───┘ └───┬───┘      │
       │         │         │         │          │
       ▼         ▼         ▼         ▼          │
   ┌─────────────────────────────────────┐      │
   │     执行Modbus TCP指令               │      │
   └─────────────────────────────────────┘      │
                             │                  │
                             ▼                  │
                    ┌─────────────────┐         │
                    │   返回JSON响应   │─────────┘
                    └─────────────────┘
```

## 四、手动控制流程图 (/send)

```
                    ┌─────────────────┐
                    │  接收控制请求    │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ 解析JSON数据    │
                    │ • jointIndex    │
                    │ • direction     │
                    │ • degree        │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ 计算复位角度    │
                    │ reset_degree =  │
                    │ (cmd+4)%8       │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ 保存复位指令    │
                    │ reset_          │
                    │ instructions[]  │
                    └────────┬────────┘
                             │
                             ▼
              ┌──────────────┴──────────────┐
              │      是否在录制模式?         │
              └──────────────┬──────────────┘
                 是│                  │否
                   ▼                  │
          ┌─────────────────┐         │
          │ 保存到          │         │
          │ instructions[]  │         │
          └────────┬────────┘         │
                   └──────────────────┤
                                      ▼
                    ┌─────────────────┐
                    │ 执行Modbus指令  │
                    │ WRITE_SINGLE_   │
                    │ REGISTER        │
                    └────────┬────────┘
                             │
                             ▼
              ┌──────────────┴──────────────┐
              │        执行成功?            │
              └──────────────┬──────────────┘
                 是│                  │否
                   ▼                  ▼
          ┌─────────────┐    ┌─────────────┐
          │ 返回成功    │    │ 记录错误日志│
          │ JSON响应    │    │ 返回错误响应│
          └─────────────┘    └─────────────┘
```

## 五、动作录制与回放流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                        录制流程                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────┐    ┌───────────┐    ┌───────────┐               │
│  │开始录制   │───►│清空指令集 │───►│record=True│               │
│  │/start_    │    │instructio │    │           │               │
│  │record     │    │ns.clear() │    │           │               │
│  └───────────┘    └───────────┘    └─────┬─────┘               │
│                                          │                      │
│                                          ▼                      │
│                                   ┌───────────┐                 │
│                                   │ 用户操作  │                 │
│                                   │ 机械臂    │◄────┐          │
│                                   └─────┬─────┘     │           │
│                                         │           │           │
│                                         ▼           │           │
│                                   ┌───────────┐     │           │
│                                   │保存到     │     │           │
│                                   │instructio │─────┘           │
│                                   │ns[]       │                 │
│                                   └─────┬─────┘                 │
│                                         │                       │
│                                         ▼                       │
│  ┌───────────┐                   ┌───────────┐                 │
│  │结束录制   │◄──────────────────│record=    │                 │
│  │/end_record│                   │False      │                 │
│  └───────────┘                   └───────────┘                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                        回放流程                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────┐                                                  │
│  │执行录制   │                                                  │
│  │/start_    │                                                  │
│  │action     │                                                  │
│  └─────┬─────┘                                                  │
│        │                                                        │
│        ▼                                                        │
│  ┌───────────────────────────┐                                 │
│  │    先执行复位操作         │                                 │
│  │ for instruction in        │                                 │
│  │    instructions:          │                                 │
│  │   execute(反向角度)       │                                 │
│  └───────────┬───────────────┘                                 │
│              │                                                  │
│              ▼                                                  │
│  ┌───────────────────────────┐                                 │
│  │   for i in range(num):    │◄─────┐                          │
│  │  (重复执行num次)          │      │                          │
│  └───────────┬───────────────┘      │                          │
│              │                      │                          │
│              ▼                      │                          │
│  ┌───────────────────────────┐      │                          │
│  │ for instruction in        │      │                          │
│  │    instructions:          │      │                          │
│  │   execute(instruction)    │      │                          │
│  └───────────┬───────────────┘      │                          │
│              │                      │                          │
│              ▼                      │                          │
│        ┌─────┴─────┐                │                          │
│        │ i < num ? │────是──────────┘                          │
│        └─────┬─────┘                                           │
│              │否                                                │
│              ▼                                                  │
│  ┌───────────────────────────┐                                 │
│  │       返回响应            │                                 │
│  └───────────────────────────┘                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 六、系统通信架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              系统通信架构                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────────┐                      ┌─────────────────┐             │
│   │  HarmonyOS设备   │                      │   Flask服务器    │             │
│   │                 │    HTTP POST/GET     │   (Python)       │             │
│   │  ┌───────────┐  │◄───────────────────►│                  │             │
│   │  │ index.js  │  │   localhost:5000     │  ┌────────────┐  │             │
│   │  └───────────┘  │                      │  │netService  │  │             │
│   │  ┌───────────┐  │                      │  │   .py      │  │             │
│   │  │index.html │  │                      │  └────────────┘  │             │
│   │  └───────────┘  │                      │                  │             │
│   └─────────────────┘                      └────────┬────────┘             │
│                                                     │                       │
│                                                     │ Modbus TCP            │
│                                                     │ Port: 502             │
│                                                     │                       │
│                                                     ▼                       │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │                    Modbus TCP 设备网络 (192.168.1.103)           │      │
│   ├─────────────────────────────────────────────────────────────────┤      │
│   │                                                                 │      │
│   │  ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐        │      │
│   │  │ Slave 1 │   │ Slave 4 │   │颜色传感器│   │其他设备 │        │      │
│   │  │ 机械臂  │   │LED数码管│   │ Addr:14 │   │         │        │      │
│   │  ├─────────┤   ├─────────┤   └─────────┘   └─────────┘        │      │
│   │  │Addr 0-6:│   │Addr 0:  │                                     │      │
│   │  │关节控制 │   │十位显示 │                                     │      │
│   │  │Addr 7:  │   │Addr 1:  │                                     │      │
│   │  │1号传送带│   │个位显示 │                                     │      │
│   │  │Addr 8:  │   │Addr 2:  │                                     │      │
│   │  │2号传送带│   │显示开关 │                                     │      │
│   │  └─────────┘   └─────────┘                                     │      │
│   │                                                                 │      │
│   └─────────────────────────────────────────────────────────────────┘      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 七、命令编码对照表

| 命令名称 | 编码值 | 说明 |
|---------|-------|------|
| forward1 | 1 | 正向旋转1° |
| forward2 | 2 | 正向旋转2° |
| forward3 | 3 | 正向旋转3° |
| forward5 | 4 | 正向旋转5° |
| backward1 | 5 | 反向旋转1° |
| backward2 | 6 | 反向旋转2° |
| backward3 | 7 | 反向旋转3° |
| backward5 | 8 | 反向旋转5° |

## 八、API接口列表

| 接口路径 | 方法 | 功能描述 |
|---------|------|---------|
| /send | POST | 手动控制机械臂关节 |
| /reset | POST | 复位到初始位置 |
| /SoftReset | POST | 软复位(回退一步) |
| /pump | POST | 控制1号传送带 |
| /pump2 | POST | 控制2号传送带 |
| /start_transport | POST | 启动自动搬运 |
| /pause_transport | POST | 暂停/继续搬运 |
| /get_transport_status | GET | 获取搬运状态 |
| /change_Led | POST | 更改LED显示数字 |
| /start_record | POST | 开始录制动作 |
| /end_record | POST | 结束录制动作 |
| /start_action | POST | 执行录制的动作 |

## 九、前端界面功能模块图

```
┌─────────────────────────────────────────────────────────────────┐
│                        前端界面结构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌────────────────────── 状态显示区 ──────────────────────┐    │
│  │  [red_box: X]          [all_box: X]          [退出]    │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                 │
│  ┌────────────────────── 传送带控制区 ────────────────────┐    │
│  │  [复位]  [开启/关闭1号传送带]  [开启/关闭2号传送带]     │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                 │
│  ┌────────────────────── 关节控制区 ──────────────────────┐    │
│  │  [关节选择▼]  [方向选择▼]  [角度选择▼]  [确认]        │    │
│  │   1-6号关节    正向/反向    1°/2°/3°/5°                │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                 │
│  ┌────────────────────── 搬运控制区 ──────────────────────┐    │
│  │  [-]  [搬运数量: X]  [+]  [开始搬运]  [暂停]  [软复位] │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                 │
│  ┌────────────────────── 动作录制区 ──────────────────────┐    │
│  │  [开启/关闭录制]  [-]  [执行次数: X]  [+]  [执行]      │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 十、功能模块详解及程序代码

### 模块一：自动搬运功能

#### 1.1 功能概述

自动搬运功能实现机械臂按照预设的动作序列自动完成物料搬运任务，包括：
- 从传送带上抓取物料
- 颜色识别与分类计数
- 将物料放置到目标位置
- 循环执行指定次数

#### 1.2 流程图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          自动搬运功能流程图                                   │
└─────────────────────────────────────────────────────────────────────────────┘

                              ┌───────────────┐
                              │  用户点击     │
                              │ "开始搬运"    │
                              └───────┬───────┘
                                      │
                                      ▼
                        ┌─────────────────────────┐
                        │   前端发送HTTP请求       │
                        │   POST /start_transport │
                        │   {num, count_box,      │
                        │    red_box}             │
                        └───────────┬─────────────┘
                                    │
                                    ▼
                        ┌─────────────────────────┐
                        │   检查是否已在运行       │
                        │   transport_running?    │
                        └───────────┬─────────────┘
                             是│          │否
                               ▼          ▼
                    ┌──────────────┐  ┌──────────────────┐
                    │ 返回错误     │  │ 创建后台线程     │
                    │ "已在运行"   │  │ threading.Thread │
                    └──────────────┘  └────────┬─────────┘
                                               │
                                               ▼
                              ┌─────────────────────────┐
                              │   do_transport()       │
                              │   后台线程执行          │
                              └───────────┬─────────────┘
                                          │
                    ┌─────────────────────┴─────────────────────┐
                    │           外层循环 while(num > 0)          │
                    └─────────────────────┬─────────────────────┘
                                          │
                              ┌───────────┴───────────┐
                              │   wait_if_paused()    │
                              │   检查暂停状态         │
                              └───────────┬───────────┘
                                          │
                              ┌───────────┴───────────┐
                              │   更新LED数码管显示    │
                              │   显示当前进度         │
                              └───────────┬───────────┘
                                          │
                              ┌───────────┴───────────┐
                              │   开启2号传送带        │
                              │   address=8, value=1  │
                              └───────────┬───────────┘
                                          │
                    ┌─────────────────────┴─────────────────────┐
                    │     内层循环：执行 auto_instructions       │
                    │     nowStep = 0 to len(auto_instructions) │
                    └─────────────────────┬─────────────────────┘
                                          │
                              ┌───────────┴───────────┐
                              │   判断指令类型         │
                              └───────────┬───────────┘
                                          │
                    ┌─────────────────────┼─────────────────────┐
                    │                     │                     │
                    ▼                     ▼                     ▼
          ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐
          │ 普通动作指令    │   │ 颜色识别指令    │   │ 吸盘控制指令    │
          │ addr: 0-4       │   │ addr: 14        │   │ addr: 6         │
          │                 │   │                 │   │                 │
          │ 发送Modbus指令  │   │ 循环读取传感器  │   │ 1=吸取 2=释放   │
          │ 控制关节旋转    │   │ 直到检测到颜色  │   │                 │
          └────────┬────────┘   └────────┬────────┘   └────────┬────────┘
                   │                     │                     │
                   │            ┌────────┴────────┐            │
                   │            │ 颜色==1(红色)?  │            │
                   │            └────────┬────────┘            │
                   │               是│      │否               │
                   │                 ▼      │                  │
                   │          ┌──────────┐  │                  │
                   │          │red_box++ │  │                  │
                   │          └────┬─────┘  │                  │
                   │               └────────┤                  │
                   └───────────────────────┬┴──────────────────┘
                                           │
                              ┌────────────┴────────────┐
                              │   nowStep++             │
                              │   继续下一条指令        │
                              └────────────┬────────────┘
                                           │
                              ┌────────────┴────────────┐
                              │   内层循环结束          │
                              │   一次搬运完成          │
                              └────────────┬────────────┘
                                           │
                              ┌────────────┴────────────┐
                              │   num--; count_box++    │
                              │   更新transport_result  │
                              └────────────┬────────────┘
                                           │
                              ┌────────────┴────────────┐
                              │     num > 0 ?           │
                              └────────────┬────────────┘
                                    是│          │否
                                      │          ▼
                                      │   ┌──────────────────┐
                                      │   │ 更新最终LED显示  │
                                      │   │ transport_running│
                                      │   │    = False       │
                                      │   │ 搬运任务完成     │
                                      │   └──────────────────┘
                                      │
                                      └──► 继续外层循环
```

#### 1.3 核心代码及解释

**后端代码 (netService.py)**

```python
# ============================================
# 全局状态变量
# ============================================
transport_paused = False    # 暂停状态标志
transport_running = False   # 运行状态标志
transport_result = {'count_box': 0, 'red_box': 0}  # 搬运结果
nowStep = 0                 # 当前执行步骤索引

# ============================================
# 预设的自动搬运动作序列
# 格式: [slave, address, value]
# ============================================
auto_instructions = [
    [1, 7, 1],      # 开启1号传送带
    [1, 0, 4],      # 1号关节正向旋转5°（重复10次）
    # ... 省略重复指令 ...
    [1, 2, 8],      # 3号关节反向旋转5°（重复12次）
    [1, 1, 4],      # 2号关节正向旋转5°（重复3次）
    [1, 4, 4],      # 5号关节正向旋转5°（重复24次）
    [1, 14, 1],     # 颜色识别（特殊指令）
    [1, 6, 1],      # 吸盘吸取
    [1, 0, 8],      # 1号关节反向旋转5°（移动到目标位置）
    [1, 6, 2],      # 吸盘释放
    # ... 复位动作序列 ...
]

# ============================================
# 暂停等待函数
# ============================================
def wait_if_paused():
    """当暂停标志为True时，循环等待直到恢复"""
    global transport_paused
    while transport_paused:
        time.sleep(0.1)  # 每100ms检查一次

# ============================================
# 自动搬运核心函数（后台线程执行）
# ============================================
def do_transport(num, count_box, red_box):
    """
    执行自动搬运任务
    参数:
        num: 要搬运的物料数量
        count_box: 已搬运总数（用于续传）
        red_box: 红色物料计数
    """
    global transport_running, transport_result, nowStep
    
    # 外层循环：执行num次搬运
    while num > 0:
        # 检查是否暂停
        wait_if_paused()
        
        # 计算并显示当前进度（LED数码管）
        tens = count_box // 10
        ones = count_box % 10
        if ones == 0: ones = 10
        if tens == 0: tens = 10
        
        try:
            # 更新LED数码管显示
            master_tcp.execute(slave=4, function_code=cst.WRITE_SINGLE_REGISTER,
                             starting_address=0x0002, output_value=1)  # 开启显示
            master_tcp.execute(slave=4, function_code=cst.WRITE_SINGLE_REGISTER,
                             starting_address=0x0000, output_value=tens)  # 十位
            master_tcp.execute(slave=4, function_code=cst.WRITE_SINGLE_REGISTER,
                             starting_address=0x0001, output_value=ones)  # 个位
            
            # 开启2号传送带
            master_tcp.execute(slave=1, function_code=cst.WRITE_SINGLE_REGISTER,
                             starting_address=8, output_value=1)
            
            # 内层循环：执行动作序列
            nowStep = 0
            while nowStep < len(auto_instructions):
                wait_if_paused()  # 每步检查暂停
                instruction = auto_instructions[nowStep]
                
                # 判断指令类型
                if instruction[1] != 14:
                    # 普通指令：直接发送Modbus写指令
                    master_tcp.execute(
                        instruction[0],                    # slave
                        cst.WRITE_SINGLE_REGISTER,        # 功能码06
                        instruction[1],                    # address
                        output_value=instruction[2]        # value
                    )
                else:
                    # 颜色识别指令：循环读取直到检测到物体
                    while True:
                        res = master_tcp.execute(
                            slave=1,
                            function_code=cst.READ_HOLDING_REGISTERS,  # 功能码03
                            starting_address=0x000E,  # 地址14：颜色传感器
                            quantity_of_x=1
                        )
                        color_code = res[0] if res else 0
                        if color_code:  # 检测到颜色
                            if color_code == 1:  # 红色
                                red_box += 1
                            break
                
                # 前半段动作需要延时（确保机械臂运动到位）
                if nowStep <= 71:
                    time.sleep(0.1)
                nowStep += 1
            
        except Exception as e:
            logging.error(f"Error in do_transport: {e}")
            transport_running = False
            return
        
        # 一次搬运完成，更新计数
        num -= 1
        count_box += 1
        transport_result['count_box'] = count_box
        transport_result['red_box'] = red_box
    
    # 所有搬运完成
    transport_running = False
    logging.info(f'Transport completed: {transport_result}')

# ============================================
# 启动搬运API接口
# ============================================
@app.route("/start_transport", methods=["POST"])
def start_transport():
    """启动自动搬运任务"""
    global transport_running, transport_result
    
    # 防止重复启动
    if transport_running:
        return jsonify({"status": "error", "message": "Transport already running"}), 400
    
    # 解析请求参数
    data = request.json
    num = data.get("num", 10)           # 搬运数量，默认10
    count_box = data.get('count_box', 0) # 已搬运数量
    red_box = data.get('red_box', 0)     # 红色计数
    
    # 设置运行状态
    transport_running = True
    transport_result = {'count_box': count_box, 'red_box': red_box}
    
    # 创建后台线程执行搬运任务
    thread = threading.Thread(target=do_transport, args=(num, count_box, red_box))
    thread.daemon = True  # 守护线程，主程序退出时自动结束
    thread.start()
    
    return jsonify({"status": "started", "message": "Transport started in background"})
```

**前端代码 (index.js)**

```javascript
// ============================================
// 启动自动搬运
// ============================================
startTransport() {
    fetch.fetch({
        url: 'http://127.0.0.1:5000/start_transport',
        method: 'POST',
        data: {
            num: this.transportNum,      // 搬运数量
            count_box: this.count_box,   // 当前已搬运数
            red_box: this.red_box        // 红色物料计数
        },
        success: res => {
            console.log('搬运启动:', res.data);
            this.pollTransportStatus();  // 启动状态轮询
        },
        fail: err => console.error('搬运启动失败:', err)
    });
}

// ============================================
// 轮询搬运状态（实时更新UI）
// ============================================
pollTransportStatus() {
    const self = this;
    const poll = () => {
        fetch.fetch({
            url: 'http://127.0.0.1:5000/get_transport_status',
            method: 'GET',
            success: res => {
                let data = res.data;
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }
                // 更新UI数据
                if (data.result) {
                    self.count_box = data.result.count_box;
                    self.red_box = data.result.red_box;
                }
                // 如果还在运行，继续轮询
                if (data.running) {
                    setTimeout(poll, 1000);  // 1秒后再次查询
                } else {
                    console.log('搬运完成');
                }
            }
        });
    };
    setTimeout(poll, 1000);
}
```

---

### 模块二：暂停/继续功能

#### 2.1 功能概述

在自动搬运过程中，用户可以随时暂停任务，暂停后机械臂停止在当前位置，再次点击可继续执行。

#### 2.2 流程图

```
┌───────────────────────────────────────────────────────────────┐
│                      暂停/继续功能流程图                        │
└───────────────────────────────────────────────────────────────┘

            ┌───────────────┐
            │  用户点击     │
            │  "暂停"按钮   │
            └───────┬───────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  POST /pause_transport │
        └───────────┬───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  transport_paused =   │
        │  !transport_paused    │
        │  (状态取反)           │
        └───────────┬───────────┘
                    │
        ┌───────────┴───────────┐
        │   transport_paused?   │
        └───────────┬───────────┘
             True│        │False
                 ▼        ▼
        ┌─────────────┐  ┌─────────────┐
        │  搬运线程   │  │  搬运线程   │
        │  进入等待   │  │  继续执行   │
        │  wait_if_   │  │             │
        │  paused()   │  │             │
        └─────────────┘  └─────────────┘
```

#### 2.3 核心代码

```python
# ============================================
# 后端：暂停/继续控制
# ============================================
@app.route("/pause_transport", methods=["POST"])
def pause_transport():
    """切换暂停状态"""
    global transport_paused
    transport_paused = not transport_paused  # 状态取反
    logging.info(f"Transport paused: {transport_paused}")
    return jsonify({"status": "success", "paused": transport_paused})

# ============================================
# 暂停检查函数（在搬运循环中调用）
# ============================================
def wait_if_paused():
    """阻塞等待直到暂停解除"""
    global transport_paused
    while transport_paused:
        time.sleep(0.1)  # 每100ms检查一次状态
```

```javascript
// ============================================
// 前端：暂停按钮事件
// ============================================
pause() {
    fetch.fetch({
        url: 'http://127.0.0.1:5000/pause_transport',
        method: 'POST',
        data: {},
        success: res => console.log('暂停/继续:', res.data),
        fail: err => console.error('操作失败:', err)
    });
}
```

---

### 模块三：动作录制与回放功能

#### 3.1 功能概述

用户可以手动操作机械臂完成一系列动作，系统会录制这些动作指令，之后可以重复播放录制的动作序列。

#### 3.2 流程图

```
┌───────────────────────────────────────────────────────────────────────────────┐
│                           动作录制与回放流程图                                  │
└───────────────────────────────────────────────────────────────────────────────┘

                              【录制流程】

            ┌───────────────┐
            │  用户点击     │
            │ "开启录制"    │
            └───────┬───────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  POST /start_record   │
        │  • record = True      │
        │  • instructions.clear()│
        └───────────┬───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │   用户手动操作机械臂   │◄─────┐
        │   (选择关节/方向/角度) │      │
        └───────────┬───────────┘      │
                    │                  │
                    ▼                  │
        ┌───────────────────────┐      │
        │  POST /send           │      │
        │  执行动作并保存到      │      │
        │  instructions[]       │──────┘
        └───────────┬───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  用户点击"关闭录制"   │
        │  POST /end_record     │
        │  • record = False     │
        └───────────────────────┘


                              【回放流程】

            ┌───────────────┐
            │  用户点击     │
            │   "执行"      │
            └───────┬───────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  POST /start_action   │
        │  {num: 执行次数}      │
        └───────────┬───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  Step 1: 先复位       │
        │  执行所有指令的反向   │
        │  动作，回到初始位置   │
        └───────────┬───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  Step 2: 循环执行     │◄─────┐
        │  for i in range(num)  │      │
        └───────────┬───────────┘      │
                    │                  │
                    ▼                  │
        ┌───────────────────────┐      │
        │  遍历instructions[]   │      │
        │  依次发送Modbus指令   │      │
        └───────────┬───────────┘      │
                    │                  │
                    ▼                  │
        ┌───────────────────────┐      │
        │    i < num ?          │──是──┘
        └───────────┬───────────┘
                    │否
                    ▼
        ┌───────────────────────┐
        │     执行完成          │
        └───────────────────────┘
```

#### 3.3 核心代码

```python
# ============================================
# 全局变量
# ============================================
record = False        # 录制状态标志
instructions = []     # 录制的指令列表

# ============================================
# 开始录制
# ============================================
@app.route("/start_record", methods=["POST"])
def start_record():
    """开始录制动作"""
    global record
    record = True
    instructions.clear()  # 清空之前的录制
    return jsonify({"response": len(instructions)})

# ============================================
# 结束录制
# ============================================
@app.route("/end_record", methods=["POST"])
def end_record():
    """结束录制"""
    global record
    record = False
    return jsonify({"response": len(instructions)})  # 返回录制的指令数量

# ============================================
# 手动控制（录制模式下同时保存指令）
# ============================================
@app.route("/send", methods=["POST"])
def send():
    data = request.json
    jointIndex = data.get("jointIndex")
    direction = data.get("direction")
    degree = data.get("degree")

    # 如果在录制模式，保存指令到列表
    if record:
        instructions.append([jointIndex, direction, command[f"{direction}{degree}"]])

    # 执行指令
    try:
        res = master_tcp.execute(1, cst.WRITE_SINGLE_REGISTER, jointIndex,
                                 output_value=command[f"{direction}{degree}"])
        return jsonify({"status": "success", "res": str(res)})
    except Exception as e:
        logging.error(f"Error: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

# ============================================
# 执行录制的动作
# ============================================
@app.route("/start_action", methods=["POST"])
def start_action():
    """回放录制的动作序列"""
    data = request.json
    num = data.get("num", 1)  # 执行次数
    
    try:
        # Step 1: 先复位到初始位置（执行反向动作）
        for instruction in instructions:
            # 计算反向角度: (原角度+4)%8，实现正反向互换
            reset_degree = (instruction[2] + 4) % 8
            if reset_degree == 0:
                reset_degree = 8
            master_tcp.execute(1, cst.WRITE_SINGLE_REGISTER, 
                             instruction[0], output_value=reset_degree)
        
        # Step 2: 循环执行num次
        for i in range(num):
            for instruction in instructions:
                master_tcp.execute(1, cst.WRITE_SINGLE_REGISTER,
                                 instruction[0], output_value=instruction[2])
                                 
    except Exception as e:
        return jsonify({"error": str(e)})
    
    return jsonify({"response": "success"})
```

```javascript
// ============================================
// 前端：录制开关
// ============================================
onActionChange() {
    this.pump3 = !this.pump3;  // 切换录制状态

    if (this.pump3) {
        // 开始录制
        fetch.fetch({
            url: 'http://127.0.0.1:5000/start_record',
            method: 'POST',
            data: {},
            success: res => console.log('录制开始:', res.data),
        });
    } else {
        // 结束录制
        fetch.fetch({
            url: 'http://127.0.0.1:5000/end_record',
            method: 'POST',
            data: {},
            success: res => console.log('录制结束:', res.data),
        });
    }
}

// ============================================
// 前端：执行录制动作
// ============================================
startAction() {
    fetch.fetch({
        url: 'http://127.0.0.1:5000/start_action',
        method: 'POST',
        data: {
            num: this.actionNum,  // 执行次数
        },
        success: res => console.log('执行完成:', res.data),
        fail: err => console.error('执行失败:', err)
    });
}
```

---

### 模块四：软复位功能

#### 4.1 功能概述

在自动搬运过程中，如果发生异常，用户可以点击"软复位"撤销最后一步动作，让机械臂回到上一步的位置。

#### 4.2 流程图

```
┌───────────────────────────────────────────────────────────────┐
│                        软复位功能流程图                         │
└───────────────────────────────────────────────────────────────┘

            ┌───────────────┐
            │  用户点击     │
            │  "软复位"     │
            └───────┬───────┘
                    │
                    ▼
        ┌───────────────────────┐
        │   POST /SoftReset     │
        └───────────┬───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │   nowStep -= 1        │
        │   回退一步            │
        └───────────┬───────────┘
                    │
                    ▼
        ┌───────────────────────────────────┐
        │  跳过特殊指令（颜色识别/传送带/吸盘）│
        │  while addr in [14, 7, 6]:        │
        │      nowStep -= 1                 │
        └───────────────┬───────────────────┘
                        │
                        ▼
        ┌───────────────────────────────────┐
        │  nowStep >= 0 ?                   │
        └───────────────┬───────────────────┘
                 是│          │否
                   ▼          ▼
        ┌─────────────────┐  ┌─────────────────┐
        │ 获取当前步骤指令 │  │ 已到最开始     │
        │ instruction =   │  │ 无需复位       │
        │ auto_instructions│  │                │
        │ [nowStep]       │  │                │
        └────────┬────────┘  └─────────────────┘
                 │
                 ▼
        ┌─────────────────────────────────────┐
        │  计算反向动作                        │
        │  tmp = (instruction[2] + 4) % 8    │
        │  if tmp == 0: tmp = 8              │
        └────────────────┬────────────────────┘
                         │
                         ▼
        ┌─────────────────────────────────────┐
        │  发送Modbus指令执行反向动作          │
        │  master_tcp.execute(...)            │
        │  机械臂回到上一步位置                │
        └─────────────────────────────────────┘
```

#### 4.3 核心代码

```python
# ============================================
# 软复位：撤销最后一步动作
# ============================================
@app.route("/SoftReset", methods=["POST"])
def SoftReset():
    """软复位 - 回退一步操作"""
    global nowStep
    
    # 回退一步
    nowStep -= 1
    
    # 跳过特殊指令（不能撤销的操作）
    # addr=14: 颜色识别, addr=7: 传送带, addr=6: 吸盘
    while nowStep >= 0 and auto_instructions[nowStep][1] in [14, 7, 6]:
        nowStep -= 1
    
    # 如果还有可撤销的步骤
    if nowStep >= 0:
        instruction = auto_instructions[nowStep]
        try:
            # 计算反向动作
            # 正向1-4 <-> 反向5-8，通过+4再取模实现互换
            tmp = (instruction[2] + 4) % 8
            if tmp == 0:
                tmp = 8
            
            # 执行反向动作
            master_tcp.execute(
                instruction[0],                # slave
                cst.WRITE_SINGLE_REGISTER,    # 功能码06
                instruction[1],                # address
                output_value=tmp               # 反向值
            )
        except Exception as e:
            logging.error(f"Error in SoftReset: {e}")
            return jsonify({"status": "error", "message": str(e)}), 500
    
    return jsonify({"status": "success", "nowStep": nowStep})
```

---

### 模块五：复位功能

#### 5.1 功能概述

手动操作模式下，用户可以点击"复位"按钮，将机械臂恢复到操作前的初始位置。系统会按照录制的逆序执行反向动作。

#### 5.2 核心代码

```python
# ============================================
# 全局变量：复位指令列表
# ============================================
reset_instructions = []  # 保存每次操作的反向指令

# ============================================
# 手动控制时记录复位指令
# ============================================
@app.route("/send", methods=["POST"])
def send():
    data = request.json
    jointIndex = data.get("jointIndex")
    direction = data.get("direction")
    degree = data.get("degree")

    # 计算复位角度（反向动作）
    reset_degree = (command[f"{direction}{degree}"] + 4) % 8
    if reset_degree == 0:
        reset_degree = 8

    # 保存复位指令
    reset_instructions.append([jointIndex, direction, reset_degree])
    
    # 执行动作...
    # ...

# ============================================
# 复位：执行所有反向动作
# ============================================
@app.route("/reset", methods=["POST"])
def reset():
    """复位到初始位置"""
    logging.info('reset()')

    try:
        # 遍历所有保存的复位指令，依次执行
        for instruction in reset_instructions:
            master_tcp.execute(
                1,                            # slave
                cst.WRITE_SINGLE_REGISTER,   # 功能码06
                instruction[0],               # address (关节索引)
                output_value=instruction[2]   # 反向角度值
            )
        
        # 清空复位指令列表
        reset_instructions.clear()
        
    except Exception as e:
        logging.error(f"Error: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500
    
    return jsonify({"response": len(reset_instructions)})
```

---

### 模块六：状态查询功能

#### 6.1 核心代码

```python
# ============================================
# 获取搬运状态（供前端轮询）
# ============================================
@app.route("/get_transport_status", methods=["GET"])
def get_transport_status():
    """返回当前搬运状态"""
    global transport_running, transport_result, transport_paused
    return jsonify({
        "running": transport_running,    # 是否在运行
        "paused": transport_paused,      # 是否暂停
        "result": transport_result       # 搬运结果 {count_box, red_box}
    })
```

---

### 模块总结表

| 模块名称 | API接口 | 主要功能 | 关键技术点 |
|---------|--------|---------|-----------|
| 自动搬运 | /start_transport | 自动执行预设动作序列 | 多线程、状态机、循环控制 |
| 暂停/继续 | /pause_transport | 暂停和恢复搬运任务 | 全局标志、阻塞等待 |
| 动作录制 | /start_record, /end_record | 录制用户操作 | 指令列表、录制标志 |
| 动作回放 | /start_action | 重复执行录制的动作 | 复位算法、循环执行 |
| 软复位 | /SoftReset | 撤销最后一步 | 步骤索引、反向计算 |
| 复位 | /reset | 恢复初始位置 | 指令栈、逆序执行 |
| 状态查询 | /get_transport_status | 获取运行状态 | JSON响应、轮询机制 |